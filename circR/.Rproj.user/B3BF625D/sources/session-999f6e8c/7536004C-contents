#Codes that work:

# Data for one bird, all dates

###################
library(zoo)
library(ggplot2)
library(dplyr)

# Assuming df1 is your data frame with columns: timestamp, HopsPerMinute

# Explicitly extract the date from the timestamp
df1 <- Cage_15 %>%
  mutate(Date = as.Date(format(timestamp, "%Y-%m-%d")))

# Initialize an empty list to store results for each day
results <- list()

# Loop through each unique date
for (date in unique(df1$Date)) {
  # Debug: Print the current date being processed
  print(paste("Processing date:", as.Date(date, origin = "1970-01-01")))

  # Filter data for the current date
  df_day <- df1 %>%
    filter(Date == date)

  # Debug: Print the number of rows for the current day
  print(paste("Number of rows for", as.Date(date, origin = "1970-01-01"), ":", nrow(df_day)))

  # Calculate the 20-minute rolling mean for the current day
  df_day <- df_day %>%
    mutate(rolling_mean = rollmean(HopsPerMinute, k = 20, fill = NA, align = "center"))

  # Fill NA values with 0 for rolling_mean
  df_day$rolling_mean[is.na(df_day$rolling_mean)] <- 0

  # Calculate the daily mean activity
  daily_mean <- mean(df_day$HopsPerMinute, na.rm = TRUE)
  df_day$daily_mean <- daily_mean

  # Find the intersection points
  df_day <- df_day %>%
    mutate(intersect = ifelse((lag(rolling_mean) < daily_mean & rolling_mean >= daily_mean) |
                                (lag(rolling_mean) > daily_mean & rolling_mean <= daily_mean), TRUE, FALSE))

  # Ensure the 'intersect' column is logical (TRUE/FALSE)
  df_day$intersect <- as.logical(df_day$intersect)

  # Identify the periods of sustained activity
  df_day <- df_day %>%
    mutate(activity_period = cumsum(c(TRUE, diff(intersect) != 0)))

  # Filter for meaningful onsets and offsets
  activity_periods <- df_day %>%
    group_by(activity_period) %>%
    filter(intersect == TRUE) %>%
    summarise(onset = min(timestamp), offset = max(timestamp)) %>%
    ungroup()

  # Merge the activity periods back to the original dataframe
  df_day <- df_day %>%
    left_join(activity_periods, by = "activity_period") %>%
    filter(!is.na(onset))

  # Store the results for the current day
  results[[as.character(date)]] <- df_day
}

# Combine results into a single data frame
df_combined <- bind_rows(results)

# Debug: Print the first few rows of the combined dataframe
print(head(df_combined))

# Plot the results
ggplot(df_combined, aes(x = timestamp, y = rolling_mean)) +
  geom_line() +
  geom_hline(data = df_combined %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
  geom_point(data = df_combined %>% filter(timestamp == onset | timestamp == offset), aes(y = rolling_mean), color = "blue", size = 3) +
  facet_wrap(~ Date, scales = "free_x", ncol = 1) +
  labs(title = "Rolling Average and Interpolated Crossings", x = "Time", y = "Rolling Average") +
  theme_classic()



#####################

# Data for all birds, all dates

############
library(zoo)
library(ggplot2)
library(dplyr)

# Explicitly extract the date from the timestamp
df1 <- df %>%
  mutate(Date = as.Date(format(timestamp, "%Y-%m-%d")))


# Initialize an empty list to store results for each Cage
results_all_cages <- list()

# Loop through each unique Cage
for (cage in unique(df1$Cage)) {
  # Filter data for the current Cage
  df_cage <- df1 %>%
    filter(Cage == cage)

  print(cage)

  # Initialize an empty list to store results for each day within the current Cage
  results <- list()

  # Loop through each unique date within the current Cage
  for (date in unique(df_cage$Date)) {
    # Filter data for the current date
    df_day <- df_cage %>%
      filter(Date == date)

    # Calculate the 20-minute rolling mean for the current day
    df_day <- df_day %>%
      mutate(rolling_mean = rollmean(HopsPerMinute, k = 20, fill = NA, align = "center"))

    # Fill NA values with 0 for rolling_mean
    df_day$rolling_mean[is.na(df_day$rolling_mean)] <- 0


    # Calculate the daily mean activity
    daily_mean <- mean(df_day$HopsPerMinute, na.rm = TRUE)
    df_day$daily_mean <- daily_mean


    # Find the intersection points
    df_day <- df_day %>%
      mutate(intersect = ifelse((lag(rolling_mean) < daily_mean & rolling_mean >= daily_mean) |
                                  (lag(rolling_mean) > daily_mean & rolling_mean <= daily_mean), TRUE, FALSE))

    # Ensure the 'intersect' column is logical (TRUE/FALSE)
    df_day$intersect <- as.logical(df_day$intersect)

    # Identify the periods of sustained activity
    df_day <- df_day %>%
      mutate(activity_period = cumsum(c(TRUE, diff(intersect) != 0)))


    # Filter for meaningful onsets and offsets, ensuring non-empty groups
    activity_periods <- df_day %>%
      group_by(activity_period) %>%
      filter(intersect == TRUE) %>%
      summarise(onset = if_else(any(!is.na(timestamp)), min(timestamp, na.rm = TRUE), as.POSIXct(NA)),
                offset = if_else(any(!is.na(timestamp)), max(timestamp, na.rm = TRUE), as.POSIXct(NA))) %>%
      ungroup()


    # Merge the activity periods back to the original dataframe
    df_day <- df_day %>%
      left_join(activity_periods, by = "activity_period") %>%
      filter(!is.na(onset))

    # Store the results for the current day
    results[[as.character(date)]] <- df_day
  }

  # Combine results into a single data frame for the current Cage
  df_combined_cage <- bind_rows(results)

  # Store the combined results for the current Cage in the main list
  results_all_cages[[as.character(cage)]] <- df_combined_cage
}

# Combine results from all Cages into a single data frame
df_combined_all <- bind_rows(results_all_cages)

# Save the results to a file or variable for later use
saveRDS(results_all_cages, file = "results_all_cages.rds")

# Function to plot the results for a specific Cage
plot_cage <- function(cage_number) {
  df_cage_to_plot <- results_all_cages[[as.character(cage_number)]]

  ggplot(df_cage_to_plot, aes(x = timestamp, y = rolling_mean)) +
    geom_line() +
    geom_hline(data = df_cage_to_plot %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
    geom_point(data = df_cage_to_plot %>% filter(timestamp == onset | timestamp == offset), aes(y = rolling_mean), color = "blue", size = 3) +
    facet_wrap(~ Date, scales = "free_x", ncol = 1) +
    labs(title = paste("Rolling Average and Interpolated Crossings for Cage", cage_number), x = "Time", y = "Rolling Average") +
    theme_classic()
}


plot_cage(20
)


# Initialize an empty list to store onset and offset times for each cage
onset_offset_times <- list()

# Loop through each cage in the results_all_cages list
for (cage in names(results_all_cages)) {
  df_cage <- results_all_cages[[cage]]

  # Extract the unique onset and offset times
  onset_offset <- df_cage %>%
    select(Date, onset, offset) %>%
    distinct()

  # Store the onset and offset times in the list
  onset_offset_times[[cage]] <- onset_offset
}

# Combine the onset and offset times into a single data frame for easier viewing
onset_offset_combined <- bind_rows(onset_offset_times, .id = "Cage")

# Display the onset and offset times
print(onset_offset_combined)



# Function to get onset and offset times for a specific cage
get_times <- function(cage_number) {
  onset_offset_times[[as.character(cage_number)]]
}

# Example: Get onset and offset times for cage 20
time_cage_20 <- get_times(20)
print(time_cage_20)

print(get_times(15))

#########################


# One bird, one date, onset relative to lights on, buffer set for 3 hours.
# Some times works, some times doesn't

###########


library(zoo)
library(ggplot2)
library(dplyr)

# Filter data for Cage 2 on March 7th, 2023
df_cage_2_day <- df %>%
  filter(Cage == 2 & format(timestamp, "%Y-%m-%d") == "2023-03-11")

# Calculate the rolling mean for the day
df_cage_2_day <- df_cage_2_day %>%
  mutate(
    rolling_mean = rollmean(HopsPerMinute, k = 20, fill = NA, align = "center"),
    rolling_mean = ifelse(is.na(rolling_mean), 0, rolling_mean),
    daily_mean = mean(HopsPerMinute, na.rm = TRUE)
  )

# Calculate the lights on and off times
df_cage_2_day <- df_cage_2_day %>%
  mutate(
    LightsOnTime = as.POSIXct(paste0(Date, " ", LightsOn), format = "%Y-%m-%d %I:%M %p"),
    LightsOffTime = as.POSIXct(paste0(Date, " ", LightsOff), format = "%Y-%m-%d %I:%M %p")
  )

# Define buffer period (e.g., 3 hours before lights on and after lights off)
buffer_hours <- 3
buffer_seconds <- buffer_hours * 3600
buffer_period_before_on <- df_cage_2_day$LightsOnTime[1] - buffer_seconds
buffer_period_after_off <- df_cage_2_day$LightsOffTime[1] + buffer_seconds

# Determine the activity onset and offset times with buffer periods
onset_time <- df_cage_2_day %>%
  filter(timestamp >= buffer_period_before_on & rolling_mean > daily_mean) %>%
  summarise(onset = min(timestamp, na.rm = TRUE)) %>%
  pull(onset)

offset_time <- df_cage_2_day %>%
  filter(timestamp <= buffer_period_after_off & rolling_mean > daily_mean) %>%
  summarise(offset = max(timestamp, na.rm = TRUE)) %>%
  pull(offset)

# Print the onset and offset times
print(paste("Onset time:", onset_time))
print(paste("Offset time:", offset_time))

# Plot the results
ggplot(df_cage_2_day, aes(x = timestamp, y = rolling_mean)) +
  geom_line() +
  geom_hline(yintercept = df_cage_2_day$daily_mean, linetype = "dashed", color = "red") +
  geom_vline(xintercept = as.numeric(df_cage_2_day$LightsOnTime), linetype = "dotted", color = "orange", size = 1.8) +
  geom_vline(xintercept = as.numeric(df_cage_2_day$LightsOffTime), linetype = "dotted", color = "black", size = 1.8) +
  geom_point(aes(x = onset_time, y = df_cage_2_day$rolling_mean[which.min(abs(df_cage_2_day$timestamp - onset_time))]), color = "blue", size = 3) +
  geom_point(aes(x = offset_time, y = df_cage_2_day$rolling_mean[which.min(abs(df_cage_2_day$timestamp - offset_time))]), color = "blue", size = 3) +
  labs(title = "Rolling Average and Logical Onset/Offset Relative to Lights On/Off for Cage 2 on March 7th, 2023", x = "Time", y = "Rolling Average") +
  theme_classic()

####################

# All birds, all dates, with buffer set to 3 hours



##############


library(zoo)
library(ggplot2)
library(dplyr)

# Explicitly extract the date from the timestamp
df1 <- df %>%
  mutate(Date = as.Date(format(timestamp, "%Y-%m-%d")))

# Initialize an empty list to store results for each Cage
results_all_cages <- list()

# Loop through each unique Cage
for (cage in unique(df1$Cage)) {
  # Filter data for the current Cage
  df_cage <- df1 %>%
    filter(Cage == cage)

  print(cage)

  # Initialize an empty list to store results for each day within the current Cage
  results <- list()

  # Loop through each unique date within the current Cage
  for (date in unique(df_cage$Date)) {
    # Filter data for the current date
    df_day <- df_cage %>%
      filter(Date == date)

    # Calculate the 20-minute rolling mean for the current day
    df_day <- df_day %>%
      mutate(rolling_mean = rollmean(HopsPerMinute, k = 20, fill = NA, align = "center"))

    # Fill NA values with 0 for rolling_mean
    df_day$rolling_mean[is.na(df_day$rolling_mean)] <- 0

    # Calculate the daily mean activity
    daily_mean <- mean(df_day$HopsPerMinute, na.rm = TRUE)
    df_day$daily_mean <- daily_mean

    # Calculate the lights on and off times
    df_day <- df_day %>%
      mutate(
        LightsOnTime = as.POSIXct(paste0(Date, " ", LightsOn), format = "%Y-%m-%d %I:%M %p"),
        LightsOffTime = as.POSIXct(paste0(Date, " ", LightsOff), format = "%Y-%m-%d %I:%M %p")
      )

    # Define buffer period (e.g., 3 hours before lights on and after lights off)
    buffer_hours <- 3
    buffer_seconds <- buffer_hours * 3600
    buffer_period_before_on <- df_day$LightsOnTime[1] - buffer_seconds
    buffer_period_after_off <- df_day$LightsOffTime[1] + buffer_seconds

    # Determine the activity onset and offset times with buffer periods
    onset_time <- df_day %>%
      filter(timestamp >= buffer_period_before_on & rolling_mean > daily_mean) %>%
      summarise(onset = min(timestamp, na.rm = TRUE)) %>%
      pull(onset)

    offset_time <- df_day %>%
      filter(timestamp <= buffer_period_after_off & rolling_mean > daily_mean) %>%
      summarise(offset = max(timestamp, na.rm = TRUE)) %>%
      pull(offset)

    # Merge onset and offset times into the dataframe
    df_day <- df_day %>%
      mutate(
        onset = onset_time,
        offset = offset_time
      )

    # Store the results for the current day
    results[[as.character(date)]] <- df_day
  }

  # Combine results into a single data frame for the current Cage
  df_combined_cage <- bind_rows(results)

  # Store the combined results for the current Cage in the main list
  results_all_cages[[as.character(cage)]] <- df_combined_cage
}

# Combine results from all Cages into a single data frame
df_combined_all <- bind_rows(results_all_cages)

# Save the results to a file or variable for later use
saveRDS(results_all_cages, file = "results_all_cages.rds")

# Function to plot the results for a specific Cage
plot_cage <- function(cage_number) {
  df_cage_to_plot <- results_all_cages[[as.character(cage_number)]]

  ggplot(df_cage_to_plot, aes(x = timestamp, y = rolling_mean)) +
    geom_line() +
    geom_hline(data = df_cage_to_plot %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
    geom_point(data = df_cage_to_plot %>% filter(timestamp == onset | timestamp == offset), aes(y = rolling_mean), color = "blue", size = 3) +
    facet_wrap(~ Date, scales = "free_x", ncol = 1) +
    labs(title = paste("Rolling Average and Interpolated Crossings for Cage", cage_number), x = "Time", y = "Rolling Average") +
    theme_classic()
}

# Example: Plot the results for Cage 20
plot_cage(2)

# Initialize an empty list to store onset and offset times for each cage
onset_offset_times <- list()

# Loop through each cage in the results_all_cages list
for (cage in names(results_all_cages)) {
  df_cage <- results_all_cages[[cage]]

  # Extract the unique onset and offset times
  onset_offset <- df_cage %>%
    select(Date, onset, offset) %>%
    distinct()

  # Store the onset and offset times in the list
  onset_offset_times[[cage]] <- onset_offset
}

# Combine the onset and offset times into a single data frame for easier viewing
onset_offset_combined <- bind_rows(onset_offset_times, .id = "Cage")

# Display the onset and offset times
print(onset_offset_combined)

# Function to get onset and offset times for a specific cage
get_times <- function(cage_number) {
  onset_offset_times[[as.character(cage_number)]]
}

# Example: Get onset and offset times for Cage 20
time_cage_20 <- get_times(20)
print(time_cage_20)

print(get_times(15))




###########################

#Onset works great, offset does NOT

#######################



library(zoo)
library(ggplot2)
library(dplyr)
library(lubridate)

# Define a function to find onset time based on sustained activity above the mean for a given duration
find_onset_time <- function(df, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30) {
  duration_threshold <- sustained_minutes * 60

  # Onset: first time activity reaches above the mean and stays above for sustained duration before CoG
  df_before_cog <- df %>%
    filter(timestamp <= cog_time) %>%
    arrange(timestamp)

  cumulative_time_above_mean <- 0
  onset_time <- NA
  for (i in seq_len(nrow(df_before_cog))) {
    if (df_before_cog$rolling_mean[i] > daily_mean) {
      cumulative_time_above_mean <- cumulative_time_above_mean + interval_minutes * 60
      if (cumulative_time_above_mean >= duration_threshold) {
        # Check if the activity falls back below the mean
        if (all(df_before_cog$rolling_mean[i:(i + duration_threshold / (interval_minutes * 60))] > daily_mean, na.rm = TRUE)) {
          onset_time <- df_before_cog$timestamp[i]
          break
        }
      }
    } else {
      cumulative_time_above_mean <- 0
    }
  }
  return(onset_time)
}

# Define a function to find offset time based on activity going below the mean for a given duration
find_offset_time <- function(df, daily_mean, interval_minutes = 10, sustained_minutes = 30) {
  duration_threshold <- sustained_minutes * 60

  # Offset: start from the end of the day and move backward to find the time when activity falls below the mean for the required duration
  df_end_of_day <- df %>%
    arrange(desc(timestamp))

  cumulative_time_below_mean <- 0
  offset_time <- NA
  for (i in seq_len(nrow(df_end_of_day))) {
    if (df_end_of_day$rolling_mean[i] < daily_mean) {
      cumulative_time_below_mean <- cumulative_time_below_mean + interval_minutes * 60
      if (cumulative_time_below_mean >= duration_threshold) {
        offset_time <- df_end_of_day$timestamp[i]
        break
      }
    } else {
      cumulative_time_below_mean <- 0
    }
  }
  return(offset_time)
}

# Initialize an empty list to store results for Cage 20
results <- list()

# Filter data for Cage 20
df_cage <- df %>%
  filter(Cage == 2) %>%
  mutate(Date = as.Date(format(timestamp, "%Y-%m-%d")))

# Checkpoint 1: Ensure df_cage contains data for Cage 20
print(head(df_cage))

# Loop through each unique date within Cage 20
for (date in unique(df_cage$Date)) {
  # Filter data for the current date
  df_cage_day <- df_cage %>%
    filter(Date == date)

  # Calculate the rolling mean with a window size of 10
  df_cage_day <- df_cage_day %>%
    mutate(rolling_mean = rollmean(HopsPerMinute, k = 10, fill = 0, align = "center"))

  # Calculate the daily mean activity
  daily_mean <- df_cage_day %>%
    filter(timestamp >= as.POSIXct(paste(Date, LightsOn), format="%Y-%m-%d %I:%M %p") &
             timestamp <= as.POSIXct(paste(Date, LightsOff), format="%Y-%m-%d %I:%M %p")) %>%
    summarise(mean_activity = mean(HopsPerMinute, na.rm = TRUE)) %>%
    pull(mean_activity)
  df_cage_day$daily_mean <- daily_mean

  # Checkpoint 2: Ensure daily_mean is calculated correctly
  print(paste("Date:", date, "Daily Mean:", daily_mean))

  # Calculate Center of Gravity (CoG)
  cog_time <- df_cage_day %>%
    filter(!is.na(rolling_mean)) %>%
    summarise(cog = sum(rolling_mean * as.numeric(timestamp)) / sum(rolling_mean)) %>%
    pull(cog)
  cog_time <- as.POSIXct(cog_time, origin = "1970-01-01")

  # Checkpoint 3: Ensure CoG time is calculated correctly
  print(paste("Date:", date, "CoG time:", cog_time))

  # Find the onset and offset times
  onset_time <- find_onset_time(df_cage_day, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30)
  offset_time <- find_offset_time(df_cage_day, daily_mean, interval_minutes = 10, sustained_minutes = 30)

  # Checkpoint 4: Ensure onset and offset times are calculated correctly
  print(paste("Date:", date, "Onset time:", onset_time, "Offset time:", offset_time))

  # Store the results for the current day
  results[[as.character(date)]] <- df_cage_day %>%
    mutate(onset_time = onset_time, offset_time = offset_time)
}

# Combine results into a single data frame for Cage 20
df_combined_cage <- bind_rows(results)

# Example: Plot for Cage 20 with grey background for lights off periods
ggplot(df_combined_cage, aes(x = timestamp, y = rolling_mean)) +
  geom_rect(data = df_combined_cage %>% mutate(start_time = as.POSIXct(paste(Date, "00:00"), format="%Y-%m-%d %H:%M")),
            aes(xmin = start_time, xmax = as.POSIXct(paste(Date, "09:00"), format="%Y-%m-%d %H:%M"), ymin = -Inf, ymax = Inf),
            fill = "grey", alpha = 0.5) +
  geom_rect(data = df_combined_cage %>% mutate(start_time = as.POSIXct(paste(Date, "00:00"), format="%Y-%m-%d %H:%M")),
            aes(xmin = as.POSIXct(paste(Date, "21:00"), format="%Y-%m-%d %H:%M"), xmax = start_time + days(1), ymin = -Inf, ymax = Inf),
            fill = "grey", alpha = 0.5) +
  geom_line() +
  geom_hline(data = df_combined_cage %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = as.numeric(onset_time)), linetype = "dotted", color = "blue", size = 2) +
  geom_vline(aes(xintercept = as.numeric(offset_time)), linetype = "dotted", color = "blue", size = 2) +
  facet_wrap(~ Date, scales = "free_x", ncol = 1) +
  labs(title = "Rolling Average and Onset/Offset Relative to CoG for Cage 20", x = "Time", y = "Rolling Average") +
  theme_classic()


##########################

#This works for one bird at a time

#################


library(dplyr)
library(zoo)
library(ggplot2)

# Define the function to find onset time based on sustained activity above the mean for a given duration
find_onset_time <- function(df, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30) {
  duration_threshold <- sustained_minutes * 60

  # Onset: first time activity reaches above the mean and stays above for sustained duration before CoG
  df_before_cog <- df %>%
    filter(timestamp <= cog_time) %>%
    arrange(timestamp)

  if (nrow(df_before_cog) == 0) {
    return(NA)
  }

  cumulative_time_above_mean <- 0
  onset_time <- NA
  for (i in seq_len(nrow(df_before_cog))) {
    if (!is.na(df_before_cog$rolling_mean_10[i]) && df_before_cog$rolling_mean_10[i] > daily_mean) {
      cumulative_time_above_mean <- cumulative_time_above_mean + interval_minutes * 60
      if (cumulative_time_above_mean >= duration_threshold) {
        # Check if the activity falls back below the mean
        if (all(df_before_cog$rolling_mean_10[i:(i + duration_threshold / (interval_minutes * 60))] > daily_mean, na.rm = TRUE)) {
          onset_time <- df_before_cog$timestamp[i]
          break
        }
      }
    } else {
      cumulative_time_above_mean <- 0
    }
  }
  return(onset_time)
}

# Calculate daily mean, onset time with custom function, and offset time with rolling mean of 30
calculate_metrics <- function(data) {
  data <- data %>%
    arrange(timestamp) %>%
    mutate(rolling_mean_10 = rollmean(HopsPerMinute, k = 10, fill = NA, align = "right"),
           rolling_mean_30 = rollmean(HopsPerMinute, k = 30, fill = NA, align = "right"))

  daily_mean <- mean(data$HopsPerMinute, na.rm = TRUE)
  cog_time <- as.POSIXct(data$timestamp[floor(nrow(data)/2)], origin="1970-01-01") # Example CoG time

  onset_time <- find_onset_time(data, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30)

  offset_time <- data %>%
    filter(rolling_mean_30 > daily_mean) %>%
    slice_tail(n = 1) %>%
    pull(timestamp)

  if (length(offset_time) == 0) {
    offset_time <- NA
  }

  data <- data %>%
    mutate(daily_mean = daily_mean,
           onset_time = onset_time,
           offset_time = offset_time)

  return(data)
}

# Filter data for Cage 20
cage_20_data <- df %>%
  filter(Cage == 20)

# Get unique dates for Cage 20
unique_dates <- unique(cage_20_data$Date)

# Initialize a list to store results
results <- list()

# Loop through each date to calculate metrics
for (date in unique_dates) {
  daily_data <- cage_20_data %>%
    filter(Date == date)

  if (nrow(daily_data) > 0) {
    metrics <- calculate_metrics(daily_data)
    results[[as.character(date)]] <- metrics
  }
}

# Combine results into a single data frame
combined_data <- bind_rows(results)

# Extract onset and offset times for each day
onset_offset_times <- combined_data %>%
  select(Date, onset_time, offset_time) %>%
  distinct() %>%
  arrange(Date)

# Print the onset and offset times
print(onset_offset_times)

# Plotting
ggplot(combined_data, aes(x = timestamp, y = rolling_mean_10)) +
  geom_rect(data = combined_data %>% mutate(start_time = as.POSIXct(paste(Date, "00:00"), format="%Y-%m-%d %H:%M")),
            aes(xmin = start_time, xmax = as.POSIXct(paste(Date, "09:00"), format="%Y-%m-%d %H:%M"), ymin = -Inf, ymax = Inf),
            fill = "grey", alpha = 0.5) +
  geom_rect(data = combined_data %>% mutate(start_time = as.POSIXct(paste(Date, "00:00"), format="%Y-%m-%d %H:%M")),
            aes(xmin = as.POSIXct(paste(Date, "21:00"), format="%Y-%m-%d %H:%M"), xmax = start_time + days(1), ymin = -Inf, ymax = Inf),
            fill = "grey", alpha = 0.5) +
  geom_line(aes(y = rolling_mean_10), color = "black") +
  geom_hline(data = combined_data %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = as.numeric(onset_time)), linetype = "dotted", color = "blue", size = 1) +
  geom_vline(aes(xintercept = as.numeric(offset_time)), linetype = "dotted", color = "blue", size = 1) +
  facet_wrap(~ Date, scales = "free_x", ncol = 1) +
  labs(title = "Rolling Average and Onset/Offset Relative to CoG for Cage 20", x = "Time", y = "Rolling Average") +
  theme_classic()


##########################

# All works

#####################

library(dplyr)
library(zoo)
library(ggplot2)

# Define the function to find onset time based on sustained activity above the mean for a given duration
find_onset_time <- function(df, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30) {
  duration_threshold <- sustained_minutes * 60

  # Onset: first time activity reaches above the mean and stays above for sustained duration before CoG
  df_before_cog <- df %>%
    filter(timestamp <= cog_time) %>%
    arrange(timestamp)

  if (nrow(df_before_cog) == 0) {
    return(NA)
  }

  cumulative_time_above_mean <- 0
  onset_time <- NA
  for (i in seq_len(nrow(df_before_cog))) {
    if (!is.na(df_before_cog$rolling_mean_10[i]) && df_before_cog$rolling_mean_10[i] > daily_mean) {
      cumulative_time_above_mean <- cumulative_time_above_mean + interval_minutes * 60
      if (cumulative_time_above_mean >= duration_threshold) {
        # Check if the activity falls back below the mean
        if (all(df_before_cog$rolling_mean_10[i:(i + duration_threshold / (interval_minutes * 60))] > daily_mean, na.rm = TRUE)) {
          onset_time <- df_before_cog$timestamp[i]
          break
        }
      }
    } else {
      cumulative_time_above_mean <- 0
    }
  }
  return(onset_time)
}

# Calculate daily mean, onset time with custom function, and offset time with rolling mean of 30
calculate_metrics <- function(data) {
  data <- data %>%
    arrange(timestamp) %>%
    mutate(rolling_mean_10 = rollmean(HopsPerMinute, k = 10, fill = NA, align = "right"),
           rolling_mean_30 = rollmean(HopsPerMinute, k = 30, fill = NA, align = "right"))

  daily_mean <- mean(data$HopsPerMinute, na.rm = TRUE)
  cog_time <- as.POSIXct(data$timestamp[floor(nrow(data)/2)], origin="1970-01-01") # Example CoG time

  onset_time <- find_onset_time(data, cog_time, daily_mean, interval_minutes = 10, sustained_minutes = 30)

  offset_time <- data %>%
    filter(rolling_mean_30 > daily_mean) %>%
    slice_tail(n = 1) %>%
    pull(timestamp)

  if (length(offset_time) == 0) {
    offset_time <- NA
  }

  data <- data %>%
    mutate(daily_mean = daily_mean,
           onset_time = onset_time,
           offset_time = offset_time)

  return(data)
}

# Filter data for all cages
unique_cages <- unique(df$Cage)

# Initialize a list to store results
results <- list()

# Loop through each cage and date to calculate metrics
for (cage in unique_cages) {
  cage_data <- df %>%
    filter(Cage == cage)

  unique_dates <- unique(cage_data$Date)

  for (date in unique_dates) {
    daily_data <- cage_data %>%
      filter(Date == date)

    if (nrow(daily_data) > 0) {
      metrics <- calculate_metrics(daily_data)
      results[[paste(cage, date, sep = "_")]] <- metrics
    }
  }
}

# Combine results into a single data frame
combined_data <- bind_rows(results)

# Function to extract and print onset and offset times for a specific cage
extract_times <- function(cage_number) {
  on_off_times <- combined_data %>%
    filter(Cage == cage_number) %>%
    select(Cage, Date, onset_time, offset_time) %>%
    distinct() %>%
    arrange(Date)

  print(on_off_times)
}

# Example: Extract and print onset and offset times for Cage 20
extract_times(2)

# Function to plot data for a specific cage
plot_cage_data <- function(cage_number) {
  cage_data <- combined_data %>%
    filter(Cage == cage_number)

  ggplot(cage_data, aes(x = timestamp, y = rolling_mean_10)) +
    geom_rect(data = cage_data,
              aes(xmin = as.POSIXct(paste(Date, "00:00"), format="%Y-%m-%d %H:%M"),
                  xmax = as.POSIXct(paste(Date, LightsOn), format="%Y-%m-%d %I:%M %p"), ymin = -Inf, ymax = Inf),
              fill = "grey", alpha = 0.5) +
    geom_rect(data = cage_data,
              aes(xmin = as.POSIXct(paste(Date, LightsOff), format="%Y-%m-%d %I:%M %p"),
                  xmax = as.POSIXct(paste(Date, "23:59"), format="%Y-%m-%d %H:%M"), ymin = -Inf, ymax = Inf),
              fill = "grey", alpha = 0.5) +
    geom_line(aes(y = rolling_mean_10), color = "black") +
    geom_hline(data = cage_data %>% distinct(Date, daily_mean), aes(yintercept = daily_mean), linetype = "dashed", color = "red") +
    geom_point(aes(x = onset_time, y = 0), color = "blue", size = 2) +
    geom_point(aes(x = offset_time, y = 0), color = "blue", size = 2) +
    facet_wrap(~ Date, scales = "free_x", ncol = 1) +
    labs(title = paste("Rolling Average and Onset/Offset Relative to CoG for Cage", cage_number), x = "Time", y = "Rolling Average") +
    theme_classic()
}

# Example: Plot data for Cage 20
plot_cage_data(20)


############################


